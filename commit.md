# Claude Command: Commit

This command helps you create well-formatted commits with conventional commit messages and emoji.

## Usage

To create a commit, just type:
```
/commit
```

Or with options:
```
/commit --no-verify
```

## What This Command Does

1. Unless specified with `--no-verify`, automatically runs pre-commit checks:
   - `pnpm lint` to ensure code quality
   - `pnpm build` to verify the build succeeds
2. Checks which files are staged with `git status`
3. If 0 files are staged, automatically adds all modified and new files with `git add`
4. Performs a `git diff` to understand what changes are being committed
5. Analyzes the diff to determine if multiple distinct logical changes are present
6. If multiple distinct changes are detected, suggests breaking the commit into multiple smaller commits
7. For each commit (or the single commit if not split), creates a commit message using emoji conventional commit format

## Best Practices for Commits

- **Verify before committing**: Ensure code is linted, builds correctly, and documentation is updated
- **Atomic commits**: Each commit should contain related changes that serve a single purpose
- **Split large changes**: If changes touch multiple concerns, split them into separate commits
- **Conventional commit format**: Use the format `<type>: <description>` where type is one of:
  - `feat`: A new feature
  - `fix`: A bug fix
  - `docs`: Documentation changes
  - `style`: Code style changes (formatting, etc)
  - `refactor`: Code changes that neither fix bugs nor add features
  - `perf`: Performance improvements
  - `test`: Adding or fixing tests
  - `chore`: Changes to the build process, tools, etc.
- **Present tense, imperative mood**: Write commit messages as commands (e.g., "add feature" not "added feature")
- **Concise first line**: Keep the first line under 72 characters
- **Emoji**: Each commit type is paired with an appropriate emoji:
  - âœ¨ `feat`: New feature
  - ğŸ› `fix`: Bug fix
  - ğŸ“ `docs`: Documentation
  - ğŸ’„ `style`: Formatting/style
  - â™»ï¸ `refactor`: Code refactoring
  - âš¡ï¸ `perf`: Performance improvements
  - âœ… `test`: Tests
  - ğŸ”§ `chore`: Tooling, configuration
  - ğŸš€ `ci`: CI/CD improvements
  - ğŸ—‘ï¸ `revert`: Reverting changes
  - ğŸ§ª `test`: Add a failing test
  - ğŸš¨ `fix`: Fix compiler/linter warnings
  - ğŸ”’ï¸ `fix`: Fix security issues
  - ğŸ‘¥ `chore`: Add or update contributors
  - ğŸšš `refactor`: Move or rename resources
  - ğŸ—ï¸ `refactor`: Make architectural changes
  - ğŸ”€ `chore`: Merge branches
  - ğŸ“¦ï¸ `chore`: Add or update compiled files or packages
  - â• `chore`: Add a dependency
  - â– `chore`: Remove a dependency
  - ğŸŒ± `chore`: Add or update seed files
  - ğŸ§‘â€ğŸ’» `chore`: Improve developer experience
  - ğŸ§µ `feat`: Add or update code related to multithreading or concurrency
  - ğŸ”ï¸ `feat`: Improve SEO
  - ğŸ·ï¸ `feat`: Add or update types
  - ğŸ’¬ `feat`: Add or update text and literals
  - ğŸŒ `feat`: Internationalization and localization
  - ğŸ‘” `feat`: Add or update business logic
  - ğŸ“± `feat`: Work on responsive design
  - ğŸš¸ `feat`: Improve user experience / usability
  - ğŸ©¹ `fix`: Simple fix for a non-critical issue
  - ğŸ¥… `fix`: Catch errors
  - ğŸ‘½ï¸ `fix`: Update code due to external API changes
  - ğŸ”¥ `fix`: Remove code or files
  - ğŸ¨ `style`: Improve structure/format of the code
  - ğŸš‘ï¸ `fix`: Critical hotfix
  - ğŸ‰ `chore`: Begin a project
  - ğŸ”– `chore`: Release/Version tags
  - ğŸš§ `wip`: Work in progress
  - ğŸ’š `fix`: Fix CI build
  - ğŸ“Œ `chore`: Pin dependencies to specific versions
  - ğŸ‘· `ci`: Add or update CI build system
  - ğŸ“ˆ `feat`: Add or update analytics or tracking code
  - âœï¸ `fix`: Fix typos
  - âªï¸ `revert`: Revert changes
  - ğŸ“„ `chore`: Add or update license
  - ğŸ’¥ `feat`: Introduce breaking changes
  - ğŸ± `assets`: Add or update assets
  - â™¿ï¸ `feat`: Improve accessibility
  - ğŸ’¡ `docs`: Add or update comments in source code
  - ğŸ—ƒï¸ `db`: Perform database related changes
  - ğŸ”Š `feat`: Add or update logs
  - ğŸ”‡ `fix`: Remove logs
  - ğŸ¤¡ `test`: Mock things
  - ğŸ¥š `feat`: Add or update an easter egg
  - ğŸ™ˆ `chore`: Add or update .gitignore file
  - ğŸ“¸ `test`: Add or update snapshots
  - âš—ï¸ `experiment`: Perform experiments
  - ğŸš© `feat`: Add, update, or remove feature flags
  - ğŸ’« `ui`: Add or update animations and transitions
  - âš°ï¸ `refactor`: Remove dead code
  - ğŸ¦º `feat`: Add or update code related to validation
  - âœˆï¸ `feat`: Improve offline support

## Guidelines for Splitting Commits

When analyzing the diff, consider splitting commits based on these criteria:

1. **Different concerns**: Changes to unrelated parts of the codebase
2. **Different types of changes**: Mixing features, fixes, refactoring, etc.
3. **File patterns**: Changes to different types of files (e.g., source code vs documentation)
4. **Logical grouping**: Changes that would be easier to understand or review separately
5. **Size**: Very large changes that would be clearer if broken down

## Examples

Good commit messages:
- âœ¨ feat: add user authentication system
- ğŸ› fix: resolve memory leak in rendering process
- ğŸ“ docs: update API documentation with new endpoints
- â™»ï¸ refactor: simplify error handling logic in parser
- ğŸš¨ fix: resolve linter warnings in component files
- ğŸ§‘â€ğŸ’» chore: improve developer tooling setup process
- ğŸ‘” feat: implement business logic for transaction validation
- ğŸ©¹ fix: address minor styling inconsistency in header
- ğŸš‘ï¸ fix: patch critical security vulnerability in auth flow
- ğŸ¨ style: reorganize component structure for better readability
- ğŸ”¥ fix: remove deprecated legacy code
- ğŸ¦º feat: add input validation for user registration form
- ğŸ’š fix: resolve failing CI pipeline tests
- ğŸ“ˆ feat: implement analytics tracking for user engagement
- ğŸ”’ï¸ fix: strengthen authentication password requirements
- â™¿ï¸ feat: improve form accessibility for screen readers

Example of splitting commits:
- First commit: âœ¨ feat: add new solc version type definitions
- Second commit: ğŸ“ docs: update documentation for new solc versions
- Third commit: ğŸ”§ chore: update package.json dependencies
- Fourth commit: ğŸ·ï¸ feat: add type definitions for new API endpoints
- Fifth commit: ğŸ§µ feat: improve concurrency handling in worker threads
- Sixth commit: ğŸš¨ fix: resolve linting issues in new code
- Seventh commit: âœ… test: add unit tests for new solc version features
- Eighth commit: ğŸ”’ï¸ fix: update dependencies with security vulnerabilities

## Implementation Instructions for AI

When executing this command, follow these steps:

### Step 1: Parse Arguments
- Check for `--no-verify` flag in arguments
- Set `noVerify` flag accordingly (default: false)

### Step 2: Validate Git Repository
- Run `git rev-parse --git-dir` to check if in a git repository
- If not in git repo, show error and exit

### Step 3: Pre-commit Checks (unless --no-verify)
If `noVerify` is false:
- Check if `package.json` exists in current directory
- If package.json exists, read it and check for `scripts.lint` and `scripts.build`
- If `lint` script exists:
  - Run `npm run lint` (or appropriate package manager command)
  - If lint fails, prompt: "Do you want to proceed anyway? (y/n)"
  - If user says no, exit with message to fix lint issues first
- If `build` script exists:
  - Run `npm run build` (or appropriate package manager command)  
  - If build fails, prompt: "Do you want to proceed anyway? (y/n)"
  - If user says no, exit with message to fix build issues first

### Step 4: Check and Stage Files
- Run `git status` to show current repository status
- Run `git diff --cached --name-only` to check for staged files
- If no staged files:
  - Show message: "No files staged. Adding all modified and new files..."
  - Run `git add .`
  - Run `git diff --cached --name-only` again to confirm files are staged
  - If still no staged files, show "No changes to commit" and exit

### Step 5: Analyze Changes
- Run `git diff --cached` to get diff output
- Run `git diff --cached --name-only` to get list of changed files
- Import commit-helpers.js: `import { analyzeChanges } from './commit-helpers.js'`
- Call `analyzeChanges(diffOutput, fileList)` to get suggested commit message
- Display suggested commit message

### Step 6: Get User Input for Commit Message
- Show suggested message from analysis
- Prompt: "Enter your commit message (or press Enter to use suggested):"
- If user provides message, use it; otherwise use suggested message

### Step 7: Create Commit
- Check if the commit message contains newlines (`\n`) or multiple lines
- **For single-line messages**: Use `git commit -m "message"`
- **For multi-line messages**: Use heredoc approach to preserve formatting:
  ```bash
  git commit -m "$(cat <<'EOF'
  {first-line-of-message}
  
  {additional-lines-or-body}
  {any-other-content}
  EOF
  )"
  ```
- Important: Always preserve the full commit message content, including line breaks
- Show success message with commit details
- Run `git log -1 --oneline` to show the created commit

### Step 8: Provide Feedback
- Show success confirmation
- Display the commit message that was used
- Show the latest commit information

### Helper Functions Available
Import from commit-helpers.js:
- `analyzeChanges(diffOutput, files)` - Analyze changes and suggest commit type/message
- `getEmojiForType(type)` - Get emoji for commit type
- `createCommitMessage(type, description)` - Format commit message with emoji
- `isValidCommitType(type)` - Check if commit type is valid

### Error Handling
- Handle git command failures gracefully
- Check if commit-helpers.js exists before importing
- Provide clear error messages for common issues
- Handle user interruption (Ctrl+C) gracefully

### Example Execution Flow
```
User: /commit
AI: 
1. Validates git repository
2. Runs pre-commit checks (lint, build)
3. Checks staged files, stages all if none
4. Analyzes changes â†’ suggests "âœ¨ feat: add new dashboard component"
5. Prompts user for commit message
6. Creates commit with final message
7. Shows success and commit details
```

## Command Options

- `--no-verify`: Skip running the pre-commit checks (lint, build, generate:docs)

## Important Notes

- By default, pre-commit checks (`pnpm lint`, `pnpm build`) will run to ensure code quality
- If these checks fail, you'll be asked if you want to proceed with the commit anyway or fix the issues first
- If specific files are already staged, the command will only commit those files
- If no files are staged, it will automatically stage all modified and new files
- The commit message will be constructed based on the changes detected
- Before committing, the command will review the diff to identify if multiple commits would be more appropriate
- If suggesting multiple commits, it will help you stage and commit the changes separately
- Always reviews the commit diff to ensure the message matches the changes